#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
/*This is a simple program that calculates the number of threads which could be used for paralellizing a radix-clustering.
To do so the program needs to know the maximum number of threads that can be used, the number of passes and the considered bits per pass. 
Currently these values are not being read as input, but must be written inside the program. 
The program outputs an array that says the number of new threads that the thread from the current pass can use for parallelizing
the processing of the new clusters.
By default, the first pass will always be done by one thread alone.
As an example: 
Suppose that the first pass creates 8 clusters, and the function is to be called again over each of those clusters for the second pass.
Here would be the results of the array given the available number of threads:
Number of Threads= 1 Threads_per_pass={1,0} 	=>No parallelization possible for calling the second pass
Number of Threads= 2 Threads_per_pass={1,1} 	=>The second pass will be called in a parallel way.
						For the existing 8 clusters, the second pass will be called in the existing thread for 4 clusters
						and in a new thread for the remaining clusters.
Number of Threads= 3 Threads_per_pass={1,1}	=>Same as the previous case.
Number of Threads= 4 Threads_per_pass={1,3}	=>The second pass will be called in a prallel way.
						For the existing 8 clusters, the second pass will be called in the existing thread for 2 clusters
						and in 3 new threads (one for each 2 clusters)
Number of Threads= 5 Threads_per_pass={1,3}	=>Same as the previous case.
Number of Threads= 6 Threads_per_pass={1,3}	=>Same as the previous case.
Number of Threads= 7 Threads_per_pass={1,3}	=>Same as the previous case.
Number of Threads= 8 Threads_per_pass={1,7}	=>Per cluster parallelization possible. The second pass will be called in a different thread over each 
						of the existing 8 clusters.
Number of Threads= 9 or more Threads_per_pass={1,7} =>Same as the previous case.

*/
typedef unsigned int uint;
uint* threads_per_pass;
int main(){
/*Input parameters*/
	int maxNthreads=200;
	int passes=3;
	uint bits_per_pass[3];
	bits_per_pass[0]=3;
	bits_per_pass[1]=2;
	bits_per_pass[2]=1; //Since no function is called over the clusters generated by the last pass, they are not considered for parallelizing.

/*Initialization*/
	threads_per_pass=(uint*)malloc(passes*sizeof(uint));
	threads_per_pass[0]=1;
	uint currentThreads=1;
	uint unusedThreads=maxNthreads-1;
	uint clusters_per_pass;

/*The code itself for deciding the proper parallelization*/
	int i;
	for (i=1; i<passes && unusedThreads>0; i++){
		clusters_per_pass=1<<bits_per_pass[i-1];
	printf("I=%d UnusedThreads:%d clusters_per_pass:%d currentThreads:%d newThreadsRequired:%d threadPerCluster:%d\n", i, unusedThreads, clusters_per_pass, currentThreads, (int)((clusters_per_pass*currentThreads)-currentThreads), clusters_per_pass-1);
		int val= (int) floor(       log2((double)(unusedThreads/currentThreads) +1)         ); //Could this also be written using binary shifts?
		threads_per_pass[i]=(val==0)?0:(((1<<val)-1)>=clusters_per_pass-1)?clusters_per_pass-1:(1<<val)-1;
		currentThreads+=threads_per_pass[i];
		if(threads_per_pass[i]==clusters_per_pass-1){ //Per cluster parallelization achieved (i.e. one thread per each cluster)
			unusedThreads-=	threads_per_pass[i];
		}
		else{ //No parallelization or Per block parallelization (i.e. one thread will handle a number of clusters, this number will be a power of 2). 
		//If there are still unused threads, they won't be usable in the next passes.
			unusedThreads=0;
		}
	}
	while (i<passes){
		threads_per_pass[i]=0;
		i++;
	}

/*Printing the results*/
	for (int i=0; i<passes; i++) {
		printf("Pass:%d Threads:%d\n", i, threads_per_pass[i]);
	}
	free(threads_per_pass);
	return 0;
}
